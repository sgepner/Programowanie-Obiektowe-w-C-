%\documentclass[draft,10pt]{beamer}
\documentclass[10pt]{beamer}

\usepackage[english,polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{polski}

\usepackage{define}

\eventtitle{Programowanie obiektowe w języku C++}
\title{Programowanie obiektowe w języku C++}
\author[shortname]{Stanis{\l}aw Gepner}
\institute[shortinst]{sgepner@meil.pw.edu.pl}
\date{}

\setbeamertemplate{blocks}[rounded][shadow=true]
\setbeamertemplate{navigation symbols}[]

\begin{document}

\frame{
    \titlepage
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Regulamin przedmiotu}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \frame{
%   \frametitle{Regulamin przedmiotu i zasady zaliczenia}
%   \vspace{-0.1cm}
%   \centering
%   \includegraphics[height=\textheight, keepaspectratio, trim={1.6cm 0cm 0cm 1cm}, clip]{zasady.pdf}
% }
%
% \begin{frame}{Zapisy na laboratoria}
% 	Proponowane terminy laboraorium:
% 	\begin{itemize}
% 		\item 2 x Środa 8:15-10:00
% 		\item 1 x Czwartek 10:15-12:00
% 		\item 2 x Czwartek 12:15-14:00
% 	\end{itemize}
% \end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Literatura}
  \begin{itemize}
    \item Internet
    \item C++ programming tutorials
    \item Stack Overflow
    \item C++ reference - {\color{red} \bf cppreference.com}
    \item Kompilator online: http://cpp.sh/, {\color{red} \bf http://coliru.stacked-crooked.com/}
    \item Google, Bing, Duck Duck Go
    \item Visual Studio 2015, Community or Visual Studio 2013, GCC
    \item Jak pompki - trzeba ćwiczyć, nie czytać!
  \end{itemize}
\end{frame}

\frame{
	\frametitle{Proceduralnie, czyli jak?}
	\framesubtitle{np. C, Fortran}
	\centering
	Czyli poprzez dzielenie zadania na procedury wykonujące określone operacje i przekazujące pomiędzy sobą przetwarzane dane.
	
	\begin{itemize}
		\item Zmienne,
		\item Dane,
		\item Procedury
		\item Wywoływanie procedur, przekazywanie danych przez argumenty
	\end{itemize}
	
	\includegraphics[height=3cm, keepaspectratio]{procedury.png}

	{\tiny Public domain}
}

\frame{
	\frametitle{Obiektowo, czyli jak?}
	\framesubtitle{np. C++, Java, C\# ...}
	\centering
	Zagadnienie dzielimy na obiekty łączące w sobie zarówno dane, jak i operujące na nich procedury (metody).
	
	\begin{itemize}
		\item Obiekty mogą ze sobą współdziałać
		\item Program można składać z różnych obiektów - zwiększa się modularność
		\item Obiekty (powinny) są od siebie niezależne (do pewnego stopnia)
		\item Obiekt to instancja klasy. Klasy są przepisem na zawartą w obiekcie strukturę danych i metody manipulacji
	\end{itemize}
	
		\includegraphics[height=3cm, keepaspectratio]{object}
		
		{\tiny Public domain}
}

\frame{
	\frametitle{Obiektowość:}

  Pozwala na wprowadzenie następujących koncepcji:
	\begin{itemize}
	  \item Abstrakcyjność, czyli opis problemu na wyższym, oderwanym od poszczególnych zadań poziomie.
	  \item Hermetyzacja (enkapsulacja), czyli kontrolę dostępu.
	  \item Polimorfizm, czyli wielopostaciowość.
	\end{itemize}
	
  \vspace*{5pt}
  A to pozwala na:
	
	\begin{itemize}
		\item Hierarchię klas.
		\item Lepszą (być może) organizację kodu.
		\item Dostęp do różnych obiektów poprzez jednorodny interfejs.
		\item Potencjalną łatwość utrzymania, rozwoju i współdzielenia kodu.
	\end{itemize}
}

\frame{
  \frametitle{Trochę historii}
  \framesubtitle{C language}
    \begin{itemize}
      \item Dennis Ritchie - AT\&T Bell Laboratories - 1972
      \item The C Programming Language - first specification - 1978
      \item 1989: ANSI C89, 1990: ISO C90
      \item 1999: C99 standard
      \item Still in use, and here to stay for a while
      \begin{itemize}
        \item Wide range of applications. OS, microcontrollers, ATM systems ...
        \item Efficiency and performance
        \item Provides low level access
        \item Influenced C++, Obj. C, C\#, Java, ...
      \end{itemize}
    \end{itemize}
}

\frame{
  \frametitle{Trochę historii}
  \framesubtitle{C++}
    \begin{itemize}
      \item Bjarne Stroustrup - AT\&T Bell Laboratories - 1979 'C with classes'
      \item C++ używany przez AT\&T - 1983
      \item Pierwsza specyfikacja - 1985
    \end{itemize}
    \centering
    \includegraphics[height=4cm, keepaspectratio]{bjarne-stroustrup}
}

\begin{frame}[fragile]
    \frametitle{Linus Torvalds}
  \framesubtitle{Kernel Linuxa, git, bóstwo pomniejsze ...}
  \centering
  \includegraphics[height=4cm, keepaspectratio]{linus-torvalds}
  
    (...)In other words, the only way to do good, efficient, and system-level and portable C++ ends up to limit yourself to all the things that are  basically available in C. And limiting your project to C means that people don't screw that up, and also means that you get a lot of programmers that do actually understand low-level issues and don't screw things up with any
 idiotic 'object model' crap.(...)

\end{frame}

\frame{
  \frametitle{ C++}
  Język ogólnego przeznaczenia
    \begin{itemize}
      \item Lepszy C
      \item Umożliwia abstrakcję
      \item Pozwala na programowanie zarówno proceduralne jak i obiektowe
      \item 'Rozumie' C - pozwala na kompilację kodu napisanego w C
      \item Rozbudowuję kontrolę typów - type safty, w stosunku do C (np. funkcja printf nie kontroluje typu danych)
    \end{itemize}
}

\begin{frame}[fragile]
  \frametitle{C vs C++}
  \begin{columns}
    \begin{column}{0.48\textwidth}
      \begin{lstlisting}
#include <stdio.h>
int main()
{
    int a;
    scanf("%d", &a);
    printf("Hello! a=%d\n ", a);
}
      \end{lstlisting}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{lstlisting}
#include <iostream>
int main()
{
    int a;
    std::cin >> a ;
    std::cout << "Hello! a=" << a << std::endl;
}
      \end{lstlisting}
    \end{column}
  \end{columns}
  \centering
  \begin{itemize}
    \item Zarówno scanf i printf muszą zostać poinformowane o typie poprzez formatowanie: \%d, a konkretna implementacja wybierana jest w czasie działania programu.
    \item Implementacje cin i cout są wybierane na podstawie typu zmiennej, już w czasie kompilacji.
    \item Być może jest wygodniej :)
  \end{itemize}
  
\end{frame}

\begin{frame}
  \frametitle{C++ - przestrzenie nazw - namespace}
  
  Pozwalają na organizację kodu poprzez zamykanie kodu w 
  
  \begin{itemize}
    \item namespace nazwa \{ deklaracje \} - ustala przestrzeń nazw
    \item namespace A \{ namespace B \{ namespace C \{
    \item nazwa1::nazwa2 - :: operator zasięgu - użyj nazwa2 z nazwa1
    \item using namespace nazwa; - ostrożnie!
    \item using nazwa1::nazwa2; - nazwa2 jest teraz w zasięgu
    \item namespace nazwa1 = nazwa2; - alias przestrzeni
  \end{itemize}
    
\end{frame}

\begin{frame}[fragile]
  \frametitle{namespace}
  \begin{columns}
    \begin{column}{0.48\textwidth}
      \begin{lstlisting}
#include <iostream>
namespace A{int fun();}

namespace B {namespace C {namespace D{
    int fun() {return 3;}
} } }

int main()
{
    int a = A::fun();
    int b = B::C::D::fun();
    std::cout << "Hello !! a=" << a << " b=" << b << std::endl;

    using namespace B::C;
    a=D::fun();
    std::cout << "Hello !! a=" << a << " b=" << b << std::endl;

    using D::fun;
    int c = fun();
    std::cout << "Hello !! a=" << a << " b=" << b << " c=" << c << std::endl;
      \end{lstlisting}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{lstlisting}
    namespace AA=B::C::D;
    namespace BB=A;
    a = AA::fun();
    b = BB::fun();
    std::cout << "Hello !! a=" << a << " b=" << b << std::endl;

    using namespace AA;
    using namespace BB;
    a = AA::fun();
    b = BB::fun();
    std::cout << "Hello !! a=" << a << " b=" << b << std::endl;

    a = fun();
    b = fun();
    std::cout << "Hello !! a=" << a << " b=" << b << std::endl;
}

int A::fun()
{
    return 1;
}
      \end{lstlisting}
    \end{column}
  \end{columns}
  \centering
  
\end{frame}

\begin{frame}[fragile]
  \frametitle{vector}
\begin{lstlisting}
#include <iostream>
#include <vector>

using namespace std;

int main(){
    vector<int> a(5);
    a[0] = 10;
    for(int i=1; i<a.size(); ++i){
        a[i] = 10*(i+1);
        cout << a[i] << endl;
    }
    cout << endl;
    a.pop_back();
    a.push_back(1);
    for(int i=0; i<a.size(); ++i)
        cout << a[i] << endl;
}
\end{lstlisting}

\begin{itemize}
  \item Dynamiczna - resize(20)
  \item Ciągla w pamięci - dostęp przez [ ]
\end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{new \& delete}
  \framesubtitle{zamiast malloc i free}
\begin{lstlisting}
#include <iostream>
#include <vector>

using namespace std;

struct D{
    int a;
};

int main(){
    int n=10;
    D * p = new D;
    D * tab = new D[50];
    tab[8].a = 1;
    cout << tab[8].a << endl;
    delete p;
    delete []tab;
}
\end{lstlisting}

\begin{itemize}
  \item new zamiast malloc
  \item delete zamiast free
  \item kontrola typu, malloc zwracał *void
\end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{referencja \&}
  \begin{columns}
    \begin{column}{0.48\textwidth}
      \begin{lstlisting}
#include <iostream>

using namespace std;

void fun1(int a){
  a=1;
}
void fun2(int *pa){
  *pa=2;
}
void fun3(int & a){
  a=3;
}

int main(){
  int a = 6;
  cout << a << endl;
  fun1(a);
  cout << a << endl;
  fun2(&a);
  cout << a << endl;
  fun3(a);
  cout << a << endl;
  int & b; // this will not compile
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{itemize}
        \item Przypomina wskaźnik
        \item Można przypisać tylko raz
        \item Nie może istnieć niezainicjalizowana
        \item Dalej jak zmienna
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{const}
  \begin{columns}
    \begin{column}{0.48\textwidth}
      \begin{lstlisting}
#include <iostream>

using namespace std;

#define sin cos
#define true false
#define fabs abs
#define PI 3.141592
const double pi=3.141592

pi = 3; //compiler error
\end{lstlisting}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{itemize}
        \item \#define to zło
        \item const może się pojawiać w różnych kontekstach, może określać metodę lub referencję będącą argumentem, postaramy się pokazać te przypadki wraz z naszymi postępami
        \item const jest sprawdzane w czasie kompilacji
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Klasa}
  \begin{columns}
    \begin{column}{0.48\textwidth}
\begin{lstlisting}
struct A{
  int a;
};
class B{
  public:
    int a;
  private:
    A b;
}
class C{
  public:
    A a;
    B b;
    int c[5];
};

int main(){
  C c;
  c.a.a=0;
  c.b.a=3;
  c.c[2]=9;
  c.b.b.z=2; //Will not work
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{itemize}
        \item Podobna do struct ale z hermetyzacją
        \item i kilkoma innymi dodatkami
        \item Atrybutami mogą być typy proste, inne klasy, kolekcje, wskaźniki i referencje
        \item Modyfikatory dostępu: \textit{public}, \textit{private} i \textit{protected}
        \item domyślnie wszystko private
        \item dostępne przez operator . lub $->$
        \item Przykład ...
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Funkcje w klasie? Czyli metody!}
  \begin{columns}
    \begin{column}{0.48\textwidth}
\begin{lstlisting}
#include <iostream>

using namespace std;

class person{
  public:
    void setAge(int a){ mAge=a; }
    int getAge(){ return mAge; }
    void printtS(){cout << mS << endl;}
    void calcS();
  private:
    int mAge;
    int mS;
};

void person::calcS(){
  mS = 2 * mAge;
}

int main(){
  person p;
  p.setAge(3);
  p.calcS();
  cout << p.getAge() << endl;
  p.printtS();
}


\end{lstlisting}
    \end{column}
    \begin{column}{0.48\textwidth}
      \begin{itemize}
        \item Definicja w ciele klasy (pomiędzy \{\})
        \item albo poza - z deklaracją w ciele
        \item Metoda ma dostęp do wszystkich atrybutów klasy  
        \item Zasada: ukrywaj atrybuty, wystawiaj interfejs     
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

% \begin{frame}[fragile]
%   \frametitle{Konstruktor i destruktor}
%   \begin{columns}
%     \begin{column}{0.48\textwidth}
% \vspace{-0.2cm}
% \begin{lstlisting}
% #include <iostream>
% #include <stdlib.h>
%
% using namespace std;
%
% class collection{
% public:
%   collection(){size=0; tab=NULL;}
%   collection(int s) : size(s) {allocate();}
%   collection(collection& c){
%     size=getSize();
%     //tab = ????
%     }
%   ~collection(){
%     cout << "The cleaning service!" << endl;
%     delete []tab;
%   }
%   void setSize(int a){ size=a; }
%   int getSize(){ return size; }
%   void allocate();
%   int& rTab(int i)
%   { return tab[i];}
% private:
%   int size;
%   int * tab;
% };
% \end{lstlisting}
%     \end{column}
%     \begin{column}{0.48\textwidth}
% \begin{lstlisting}
% void collection::allocate()
% {
%   tab = new int[size];
% }
%
% int main(){
%   ...
% }
% \end{lstlisting}
%       \begin{itemize}
%         \item Metody specjalne, tworzone domyslnie
%         \item Definicja w lub poza ciałem
%         \item Destruktor wywoływany przed zwolnieniem zasobów
%       \end{itemize}
%     \end{column}
%   \end{columns}
% \end{frame}



\end{document}
